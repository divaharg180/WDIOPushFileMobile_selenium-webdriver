"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const reporter_1 = __importDefault(require("@wdio/reporter"));
const uuid_1 = require("uuid");
const util_1 = require("./util");
const request_handler_1 = __importDefault(require("./request-handler"));
class TestReporter extends reporter_1.default {
    constructor() {
        super(...arguments);
        this._capabilities = {};
        this._observability = true;
        this._requestQueueHandler = request_handler_1.default.getInstance();
    }
    onRunnerStart(runnerStats) {
        this._capabilities = runnerStats.capabilities;
        this._config = runnerStats.config;
        this._sessionId = runnerStats.sessionId;
        if (typeof this._config.testObservability !== 'undefined')
            this._observability = this._config.testObservability;
    }
    onSuiteStart(suiteStats) {
        this._suiteName = suiteStats.file;
    }
    async onTestSkip(testStats) {
        var _a, _b, _c, _d, _e;
        // cucumber steps call this method. We don't want step skipped state so skip for cucumber
        const framework = (_a = this._config) === null || _a === void 0 ? void 0 : _a.framework;
        if (this._observability && framework !== 'cucumber') {
            let testData = {
                uuid: (0, uuid_1.v4)(),
                type: testStats.type,
                name: testStats.title,
                body: {
                    lang: 'webdriverio',
                    code: null
                },
                scope: testStats.fullTitle,
                scopes: (0, util_1.getHierarchy)(testStats.fullTitle),
                identifier: testStats.fullTitle,
                file_name: this._suiteName,
                location: this._suiteName,
                started_at: (new Date()).toISOString(),
                framework: framework,
                finished_at: (new Date()).toISOString(),
                duration_in_ms: testStats._duration,
                retries: { limit: 0, attempts: 0 },
                result: testStats.state,
            };
            /* istanbul ignore next */
            const cloudProvider = (0, util_1.getCloudProvider)({ options: { hostname: (_b = this._config) === null || _b === void 0 ? void 0 : _b.hostname } });
            testData.integrations = {};
            /* istanbul ignore next */
            testData.integrations[cloudProvider] = {
                capabilities: this._capabilities,
                session_id: this._sessionId,
                browser: (_c = this._capabilities) === null || _c === void 0 ? void 0 : _c.browserName,
                browser_version: (_d = this._capabilities) === null || _d === void 0 ? void 0 : _d.browserVersion,
                platform: (_e = this._capabilities) === null || _e === void 0 ? void 0 : _e.platformName,
            };
            const uploadData = {
                event_type: 'TestRunFinished',
                test_run: testData
            };
            const req = this._requestQueueHandler.add(uploadData);
            if (req.proceed && req.data) {
                await (0, util_1.uploadEventData)(req.data, req.url);
            }
        }
    }
}
exports.default = TestReporter;

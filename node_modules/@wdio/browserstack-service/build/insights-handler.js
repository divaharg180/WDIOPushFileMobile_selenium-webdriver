"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const util_1 = require("./util");
const request_handler_1 = __importDefault(require("./request-handler"));
const constants_1 = require("./constants");
class InsightsHandler {
    constructor(_browser, browserCaps, isAppAutomate, sessionId, _framework) {
        this._browser = _browser;
        this._framework = _framework;
        this._tests = {};
        this._hooks = {};
        this._commands = {};
        this._requestQueueHandler = request_handler_1.default.getInstance();
        this._requestQueueHandler.start();
        this._platformMeta = {
            browserName: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.browserName,
            browserVersion: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.browserVersion,
            platformName: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.platformName,
            caps: browserCaps,
            sessionId: sessionId,
            product: isAppAutomate ? 'app-automate' : 'automate'
        };
    }
    async before() {
        if ((0, util_1.isBrowserstackSession)(this._browser)) {
            await this._browser.execute(`browserstack_executor: {"action": "annotate", "arguments": {"data": "ObservabilitySync:${Date.now()}","level": "debug"}}`);
        }
        const gitMeta = await (0, util_1.getGitMetaData)();
        if (gitMeta) {
            this._gitConfigPath = gitMeta.root;
        }
    }
    async beforeHook(test, context) {
        const fullTitle = `${test.parent} - ${test.title}`;
        const hookId = (0, uuid_1.v4)();
        this._tests[fullTitle] = {
            uuid: hookId,
            startedAt: (new Date()).toISOString()
        };
        this.attachHookData(context, hookId);
        if (this._framework == 'mocha')
            await this.sendTestRunEvent(test, 'HookRunStarted');
    }
    async afterHook(test, result) {
        const fullTitle = (0, util_1.getUniqueIdentifier)(test);
        if (this._tests[fullTitle]) {
            this._tests[fullTitle].finishedAt = (new Date()).toISOString();
        }
        else {
            this._tests[fullTitle] = {
                finishedAt: (new Date()).toISOString()
            };
        }
        if (this._framework == 'mocha')
            await this.sendTestRunEvent(test, 'HookRunFinished', result);
    }
    async beforeTest(test) {
        const fullTitle = (0, util_1.getUniqueIdentifier)(test);
        this._tests[fullTitle] = {
            uuid: (0, uuid_1.v4)(),
            startedAt: (new Date()).toISOString()
        };
        await this.sendTestRunEvent(test, 'TestRunStarted');
    }
    async afterTest(test, result) {
        const fullTitle = (0, util_1.getUniqueIdentifier)(test);
        this._tests[fullTitle] = {
            ...(this._tests[fullTitle] || {}),
            finishedAt: (new Date()).toISOString()
        };
        await this.sendTestRunEvent(test, 'TestRunFinished', result);
    }
    /**
      * Cucumber Only
      */
    async beforeScenario(world) {
        const pickleData = world.pickle;
        const gherkinDocument = world.gherkinDocument;
        const featureData = gherkinDocument.feature;
        const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)(world);
        let testMetaData = {
            uuid: (0, uuid_1.v4)(),
            startedAt: (new Date()).toISOString()
        };
        if (pickleData) {
            testMetaData.scenario = {
                name: pickleData.name,
            };
        }
        if (gherkinDocument && featureData) {
            testMetaData.feature = {
                path: gherkinDocument.uri,
                name: featureData.name,
                description: featureData.description,
            };
        }
        this._tests[uniqueId] = testMetaData;
        await this.sendTestRunEventForCucumber(world, 'TestRunStarted');
    }
    async afterScenario(world) {
        await this.sendTestRunEventForCucumber(world, 'TestRunFinished');
    }
    async beforeStep(step, scenario) {
        var _a;
        const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)({ pickle: scenario });
        let testMetaData = this._tests[uniqueId];
        if (!testMetaData) {
            testMetaData = {
                steps: []
            };
        }
        if (testMetaData && !testMetaData.steps) {
            testMetaData.steps = [];
        }
        (_a = testMetaData.steps) === null || _a === void 0 ? void 0 : _a.push({
            id: step.id,
            text: step.text,
            keyword: step.keyword,
            started_at: (new Date()).toISOString()
        });
        this._tests[uniqueId] = testMetaData;
    }
    async afterStep(step, scenario, result) {
        var _a;
        const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)({ pickle: scenario });
        let testMetaData = this._tests[uniqueId];
        if (!testMetaData) {
            testMetaData = {
                steps: []
            };
        }
        if (!testMetaData.steps) {
            testMetaData.steps = [{
                    id: step.id,
                    text: step.text,
                    keyword: step.keyword,
                    finished_at: (new Date()).toISOString(),
                    result: result.passed ? 'PASSED' : 'FAILED',
                    duration: result.duration,
                    failure: result.error ? (0, util_1.removeAnsiColors)(result.error) : result.error
                }];
        }
        const stepDetails = (_a = testMetaData.steps) === null || _a === void 0 ? void 0 : _a.find(item => item.id == step.id);
        if (stepDetails) {
            stepDetails.finished_at = (new Date()).toISOString();
            stepDetails.result = result.passed ? 'PASSED' : 'FAILED';
            stepDetails.duration = result.duration;
            stepDetails.failure = result.error ? (0, util_1.removeAnsiColors)(result.error) : result.error;
        }
        this._tests[uniqueId] = testMetaData;
    }
    //@ts-ignore
    async uploadPending(waitTimeout = constants_1.DEFAULT_WAIT_TIMEOUT_FOR_PENDING_UPLOADS, waitInterval = constants_1.DEFAULT_WAIT_INTERVAL_FOR_PENDING_UPLOADS) {
        if (this._requestQueueHandler.pendingUploads <= 0 || waitTimeout <= 0) {
            return;
        }
        await (0, util_1.sleep)(waitInterval);
        return this.uploadPending(waitTimeout - waitInterval);
    }
    async teardown() {
        await this._requestQueueHandler.shutdown();
    }
    /**
     * misc methods
     */
    async browserCommand(commandType, args, test) {
        if (commandType === 'client:beforeCommand') {
            this._commands[`${args.sessionId}_${args.method}_${args.endpoint}`] = args;
            return;
        }
        if (!test) {
            return;
        }
        const identifier = this.getIdentifier(test);
        if (!this._tests[identifier]) {
            return;
        }
        // log screenshot
        if (Boolean(process.env.BS_TESTOPS_ALLOW_SCREENSHOTS) && (0, util_1.isScreenshotCommand)(args) && args.result.value) {
            await (0, util_1.uploadEventData)([{
                    event_type: 'LogCreated',
                    logs: [{
                            test_run_uuid: this._tests[identifier].uuid,
                            timestamp: new Date().toISOString(),
                            message: args.result.value,
                            kind: 'TEST_SCREENSHOT'
                        }]
                }], constants_1.DATA_SCREENSHOT_ENDPOINT);
        }
        const dataKey = `${args.sessionId}_${args.method}_${args.endpoint}`;
        const requestData = this._commands[dataKey];
        if (!requestData) {
            return;
        }
        // log http request
        const req = this._requestQueueHandler.add({
            event_type: 'LogCreated',
            logs: [{
                    test_run_uuid: this._tests[identifier].uuid,
                    timestamp: new Date().toISOString(),
                    kind: 'HTTP',
                    http_response: {
                        path: requestData.endpoint,
                        method: requestData.method,
                        body: requestData.body,
                        response: args.result
                    }
                }]
        });
        if (req.proceed && req.data) {
            await (0, util_1.uploadEventData)(req.data, req.url);
        }
    }
    /*
     * private methods
     */
    attachHookData(context, hookId) {
        if (!context.currentTest || !context.currentTest.parent) {
            return;
        }
        const parentTest = `${context.currentTest.parent.title} - ${context.currentTest.title}`;
        if (!this._hooks[parentTest]) {
            this._hooks[parentTest] = [];
        }
        this._hooks[parentTest].push(hookId);
    }
    /*
     * Get hierarchy info
     */
    getHierarchy(test) {
        const value = [];
        if (test.ctx && test.ctx.test) {
            let parent = test.ctx.test.parent;
            while (parent && parent.title !== '') {
                value.push(parent.title);
                parent = parent.parent;
            }
        }
        return value.reverse();
    }
    async sendTestRunEvent(test, eventType, results) {
        var _a;
        const fullTitle = (0, util_1.getUniqueIdentifier)(test);
        const testMetaData = this._tests[fullTitle];
        const testData = {
            uuid: testMetaData.uuid,
            type: test.type,
            name: test.title,
            body: {
                lang: 'webdriverio',
                code: test.body
            },
            scope: fullTitle,
            scopes: this.getHierarchy(test),
            identifier: fullTitle,
            file_name: test.file,
            location: test.file,
            vc_filepath: (this._gitConfigPath && test.file) ? path_1.default.relative(this._gitConfigPath, test.file) : undefined,
            started_at: testMetaData.startedAt,
            finished_at: testMetaData.finishedAt,
            result: 'pending',
            framework: this._framework
        };
        if ((eventType == 'TestRunFinished' || eventType == 'HookRunFinished') && results) {
            const { error, passed } = results;
            if (!passed) {
                testData.result = (error && error.message && error.message.includes('sync skip; aborting execution')) ? 'ignore' : 'failed';
                if (error && testData.result != 'skipped') {
                    testData.failure = [{ backtrace: [(0, util_1.removeAnsiColors)(error.message)] }]; // add all errors here
                    testData.failure_reason = (0, util_1.removeAnsiColors)(error.message);
                    testData.failure_type = error.message == null ? null : error.message.toString().match(/AssertionError/) ? 'AssertionError' : 'UnhandledError'; //verify if this is working
                }
            }
            else {
                testData.result = 'passed';
            }
            testData.retries = results.retries;
            testData.duration_in_ms = results.duration;
            if (this._hooks[fullTitle]) {
                testData.hooks = this._hooks[fullTitle];
            }
        }
        if (eventType == 'TestRunStarted') {
            testData.integrations = {};
            if (this._browser && this._platformMeta) {
                const provider = (0, util_1.getCloudProvider)(this._browser);
                testData.integrations[provider] = this.getIntegrationsObject();
            }
        }
        const uploadData = {
            event_type: eventType,
        };
        /* istanbul ignore if */
        if (eventType.match(/HookRun/)) {
            testData.hook_type = ((_a = testData.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) ? (0, util_1.getHookType)(testData.name.toLowerCase()) : 'undefined';
            uploadData.hook_run = testData;
        }
        else {
            uploadData.test_run = testData;
        }
        const req = this._requestQueueHandler.add(uploadData);
        if (req.proceed && req.data) {
            await (0, util_1.uploadEventData)(req.data, req.url);
        }
    }
    async sendTestRunEventForCucumber(world, eventType) {
        const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)(world);
        const { feature, scenario, steps, uuid, startedAt, finishedAt } = this._tests[uniqueId] || {};
        let fullNameWithExamples = world.pickle.name;
        const examples = (0, util_1.getScenarioExamples)(world);
        if (examples) {
            fullNameWithExamples = world.pickle.name + ' (' + examples.join(', ') + ')';
        }
        let testData = {
            uuid: uuid,
            started_at: startedAt,
            finished_at: finishedAt,
            type: 'test',
            body: {
                lang: 'webdriverio',
                code: null
            },
            name: fullNameWithExamples,
            scope: fullNameWithExamples,
            scopes: [(feature === null || feature === void 0 ? void 0 : feature.name) || ''],
            identifier: scenario === null || scenario === void 0 ? void 0 : scenario.name,
            file_name: feature === null || feature === void 0 ? void 0 : feature.path,
            vc_filepath: (this._gitConfigPath && (feature === null || feature === void 0 ? void 0 : feature.path)) ? path_1.default.relative(this._gitConfigPath, feature === null || feature === void 0 ? void 0 : feature.path) : undefined,
            location: feature === null || feature === void 0 ? void 0 : feature.path,
            framework: this._framework,
            result: 'pending',
            meta: {
                feature: feature,
                scenario: scenario,
                steps: steps,
                examples: examples
            }
        };
        if (eventType == 'TestRunStarted') {
            testData.integrations = {};
            if (this._browser && this._platformMeta) {
                const provider = (0, util_1.getCloudProvider)(this._browser);
                testData.integrations[provider] = this.getIntegrationsObject();
            }
        }
        /* istanbul ignore if */
        if (world.result) {
            let result = world.result.status.toLowerCase();
            if (result !== 'passed' && result !== 'failed') {
                result = 'skipped'; // mark UNKNOWN/UNDEFINED/AMBIGUOUS/PENDING as skipped
            }
            testData.finished_at = (new Date()).toISOString();
            testData.result = result;
            testData.duration_in_ms = world.result.duration.nanos / 1000000; // send duration in ms
            if (result === 'failed') {
                testData.failure = [
                    {
                        'backtrace': [world.result.message ? (0, util_1.removeAnsiColors)(world.result.message) : 'unknown']
                    }
                ],
                    testData.failure_reason = world.result.message ? (0, util_1.removeAnsiColors)(world.result.message) : world.result.message;
                if (world.result.message) {
                    testData.failure_type = world.result.message.match(/AssertionError/)
                        ? 'AssertionError'
                        : 'UnhandledError';
                }
            }
        }
        if (world.pickle) {
            testData.tags = world.pickle.tags.map(({ name }) => (name));
        }
        const uploadData = {
            event_type: eventType,
            test_run: testData
        };
        const req = this._requestQueueHandler.add(uploadData);
        if (req.proceed && req.data) {
            await (0, util_1.uploadEventData)(req.data, req.url);
        }
    }
    getIntegrationsObject() {
        var _a, _b, _c, _d, _e, _f;
        return {
            capabilities: (_a = this._platformMeta) === null || _a === void 0 ? void 0 : _a.caps,
            session_id: (_b = this._platformMeta) === null || _b === void 0 ? void 0 : _b.sessionId,
            browser: (_c = this._platformMeta) === null || _c === void 0 ? void 0 : _c.browserName,
            browser_version: (_d = this._platformMeta) === null || _d === void 0 ? void 0 : _d.browserVersion,
            platform: (_e = this._platformMeta) === null || _e === void 0 ? void 0 : _e.platformName,
            product: (_f = this._platformMeta) === null || _f === void 0 ? void 0 : _f.product
        };
    }
    getIdentifier(test) {
        if ('pickle' in test) {
            return (0, util_1.getUniqueIdentifierForCucumber)(test);
        }
        return (0, util_1.getUniqueIdentifier)(test);
    }
}
exports.default = InsightsHandler;

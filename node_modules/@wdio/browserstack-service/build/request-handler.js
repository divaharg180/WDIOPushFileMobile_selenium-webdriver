"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@wdio/logger"));
const constants_1 = require("./constants");
const util_1 = require("./util");
const log = (0, logger_1.default)('@wdio/browserstack-service');
class RequestQueueHandler {
    // making it private to use singleton pattern
    constructor() {
        this.queue = [];
        this.started = false;
        this.pendingUploads = 0;
    }
    static getInstance() {
        if (!RequestQueueHandler.instance) {
            RequestQueueHandler.instance = new RequestQueueHandler();
        }
        return RequestQueueHandler.instance;
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.startEventBatchPolling();
        }
    }
    add(event) {
        if (!process.env.BS_TESTOPS_BUILD_COMPLETED) {
            return {
                proceed: false
            };
        }
        if (!constants_1.BATCH_EVENT_TYPES.includes(event.event_type)) {
            return {
                proceed: true
            };
        }
        if (event.logs && event.logs[0] && event.logs[0].kind === 'TEST_SCREENSHOT') {
            return {
                proceed: true,
                data: [event],
                url: constants_1.DATA_SCREENSHOT_ENDPOINT
            };
        }
        this.queue.push(event);
        log.debug(`Added data to request queue. Queue length = ${this.queue.length}`);
        let data;
        const shouldProceed = this.shouldProceed();
        if (shouldProceed) {
            data = this.queue.splice(0, constants_1.DATA_BATCH_SIZE);
            this.resetEventBatchPolling();
            log.debug(`Sending data from request queue. Data length = ${data.length}, Queue length after removal = ${this.queue.length}`);
        }
        return {
            proceed: shouldProceed,
            data: data,
            url: constants_1.DATA_BATCH_ENDPOINT
        };
    }
    async shutdown() {
        this.removeEventBatchPolling('Shutting down');
        while (this.queue.length > 0) {
            const data = this.queue.splice(0, constants_1.DATA_BATCH_SIZE);
            await (0, util_1.batchAndPostEvents)(constants_1.DATA_BATCH_ENDPOINT, 'SHUTDOWN_QUEUE', data);
        }
    }
    startEventBatchPolling() {
        this.pollEventBatchInterval = setInterval(async () => {
            if (this.queue.length > 0) {
                const data = this.queue.splice(0, constants_1.DATA_BATCH_SIZE);
                log.debug(`Sending data from request queue. Data length = ${data.length}, Queue length after removal = ${this.queue.length}`);
                await (0, util_1.batchAndPostEvents)(constants_1.DATA_BATCH_ENDPOINT, 'INTERVAL_QUEUE', data);
            }
        }, constants_1.DATA_BATCH_INTERVAL);
    }
    resetEventBatchPolling() {
        this.removeEventBatchPolling('Resetting');
        this.startEventBatchPolling();
    }
    removeEventBatchPolling(tag) {
        if (this.pollEventBatchInterval) {
            log.debug(`${tag} request queue`);
            clearInterval(this.pollEventBatchInterval);
            this.started = false;
        }
    }
    shouldProceed() {
        return this.queue.length >= constants_1.DATA_BATCH_SIZE;
    }
}
exports.default = RequestQueueHandler;

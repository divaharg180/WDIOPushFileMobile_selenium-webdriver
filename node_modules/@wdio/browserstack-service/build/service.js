"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@wdio/logger"));
const constants_1 = require("./constants");
const got_1 = __importDefault(require("got"));
const insights_handler_1 = __importDefault(require("./insights-handler"));
const util_1 = require("./util");
const reporter_1 = __importDefault(require("./reporter"));
const log = (0, logger_1.default)('@wdio/browserstack-service');
class BrowserstackService {
    constructor(options, _caps, _config) {
        var _a;
        this._caps = _caps;
        this._config = _config;
        this._sessionBaseUrl = 'https://api.browserstack.com/automate/sessions';
        this._failReasons = [];
        this._scenariosThatRan = [];
        this._failureStatuses = ['failed', 'ambiguous', 'undefined', 'unknown'];
        this._specsRan = false;
        this._options = { ...constants_1.DEFAULT_OPTIONS, ...options };
        // added to maintain backward compatibility with webdriverIO v5
        this._config || (this._config = this._options);
        this._observability = this._options.testObservability;
        if (this._observability) {
            (_a = this._config.reporters) === null || _a === void 0 ? void 0 : _a.push(reporter_1.default);
        }
        // Cucumber specific
        const strict = Boolean(this._config.cucumberOpts && this._config.cucumberOpts.strict);
        // See https://github.com/cucumber/cucumber-js/blob/master/src/runtime/index.ts#L136
        if (strict) {
            this._failureStatuses.push('pending');
        }
    }
    _updateCaps(fn) {
        const multiRemoteCap = this._caps;
        if (multiRemoteCap.capabilities) {
            return Object.entries(multiRemoteCap).forEach(([, caps]) => fn(caps.capabilities));
        }
        return fn(this._caps);
    }
    beforeSession(config) {
        // if no user and key is specified even though a browserstack service was
        // provided set user and key with values so that the session request
        // will fail
        if (!config.user) {
            config.user = 'NotSetUser';
        }
        if (!config.key) {
            config.key = 'NotSetKey';
        }
        this._config.user = config.user;
        this._config.key = config.key;
    }
    async before(caps, specs, browser) {
        // added to maintain backward compatibility with webdriverIO v5
        this._browser = browser ? browser : global.browser;
        // Ensure capabilities are not null in case of multiremote
        if (this._isAppAutomate()) {
            this._sessionBaseUrl = 'https://api-cloud.browserstack.com/app-automate/sessions';
        }
        this._scenariosThatRan = [];
        if (this._observability && this._browser) {
            this._insightsHandler = new insights_handler_1.default(this._browser, this._browser.capabilities, this._isAppAutomate(), this._browser.sessionId, this._config.framework);
            await this._insightsHandler.before();
            /**
             * register command event
             */
            this._browser.on('command', async (command) => {
                var _a, _b;
                return await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.browserCommand('client:beforeCommand', Object.assign(command, { sessionId: (_b = this._browser) === null || _b === void 0 ? void 0 : _b.sessionId }), this._currentTest));
            });
            /**
             * register result event
             */
            this._browser.on('result', async (result) => {
                var _a, _b;
                return await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.browserCommand('client:afterCommand', Object.assign(result, { sessionId: (_b = this._browser) === null || _b === void 0 ? void 0 : _b.sessionId }), this._currentTest));
            });
        }
        return await this._printSessionURL();
    }
    /**
     * Set the default job name at the suite level to make sure we account
     * for the cases where there is a long running `before` function for a
     * suite or one that can fail.
     * Don't do this for Jasmine because `suite.title` is `Jasmine__TopLevel__Suite`
     * and `suite.fullTitle` is `undefined`, so no alternative to use for the job name.
     */
    async beforeSuite(suite) {
        this._suiteTitle = suite.title;
        if (suite.title && suite.title !== 'Jasmine__TopLevel__Suite') {
            await this._setSessionName(suite.title);
        }
    }
    async beforeHook(test, context) {
        var _a;
        if (this._config.framework !== 'cucumber')
            this._currentTest = test; // not update currentTest when this is called for cucumber step
        await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.beforeHook(test, context));
    }
    async afterHook(test, context, result) {
        var _a;
        await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.afterHook(test, result));
    }
    async beforeTest(test) {
        var _a, _b;
        this._currentTest = test;
        let suiteTitle = this._suiteTitle;
        if (test.fullName) {
            // For Jasmine, `suite.title` is `Jasmine__TopLevel__Suite`.
            // This tweak allows us to set the real suite name.
            const testSuiteName = test.fullName.slice(0, test.fullName.indexOf(test.description || '') - 1);
            if (this._suiteTitle === 'Jasmine__TopLevel__Suite') {
                suiteTitle = testSuiteName;
            }
            else if (this._suiteTitle) {
                suiteTitle = (0, util_1.getParentSuiteName)(this._suiteTitle, testSuiteName);
            }
        }
        await this._setSessionName(suiteTitle, test);
        await this._setAnnotation(`Test: ${(_a = test.fullName) !== null && _a !== void 0 ? _a : test.title}`);
        await ((_b = this._insightsHandler) === null || _b === void 0 ? void 0 : _b.beforeTest(test));
    }
    async afterTest(test, context, results) {
        var _a;
        this._specsRan = true;
        const { error, passed } = results;
        if (!passed) {
            this._failReasons.push((error && error.message) || 'Unknown Error');
        }
        await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.afterTest(test, results));
    }
    async after(result) {
        var _a, _b;
        const { preferScenarioName, setSessionName, setSessionStatus } = this._options;
        // For Cucumber: Checks scenarios that ran (i.e. not skipped) on the session
        // Only 1 Scenario ran and option enabled => Redefine session name to Scenario's name
        if (preferScenarioName && this._scenariosThatRan.length === 1) {
            this._fullTitle = this._scenariosThatRan.pop();
        }
        if (setSessionStatus) {
            const hasReasons = this._failReasons.length > 0;
            await this._updateJob({
                status: result === 0 && this._specsRan ? 'passed' : 'failed',
                ...(setSessionName ? { name: this._fullTitle } : {}),
                ...(hasReasons ? { reason: this._failReasons.join('\n') } : {})
            });
        }
        await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.uploadPending());
        await ((_b = this._insightsHandler) === null || _b === void 0 ? void 0 : _b.teardown());
    }
    /**
     * For CucumberJS
     */
    async beforeFeature(uri, feature) {
        this._suiteTitle = feature.name;
        await this._setSessionName(feature.name);
        await this._setAnnotation(`Feature: ${feature.name}`);
    }
    /**
     * Runs before a Cucumber Scenario.
     * @param world world object containing information on pickle and test step
     */
    async beforeScenario(world) {
        var _a;
        this._currentTest = world;
        await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.beforeScenario(world));
        const scenarioName = world.pickle.name || 'unknown scenario';
        await this._setAnnotation(`Scenario: ${scenarioName}`);
    }
    async afterScenario(world) {
        var _a, _b;
        this._specsRan = true;
        const status = (_a = world.result) === null || _a === void 0 ? void 0 : _a.status.toLowerCase();
        if (status !== 'skipped') {
            this._scenariosThatRan.push(world.pickle.name || 'unknown pickle name');
        }
        if (status && this._failureStatuses.includes(status)) {
            const exception = ((world.result && world.result.message) ||
                (status === 'pending'
                    ? `Some steps/hooks are pending for scenario "${world.pickle.name}"`
                    : 'Unknown Error'));
            this._failReasons.push(exception);
        }
        await ((_b = this._insightsHandler) === null || _b === void 0 ? void 0 : _b.afterScenario(world));
    }
    async beforeStep(step, scenario) {
        var _a;
        await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.beforeStep(step, scenario));
        await this._setAnnotation(`Step: ${step.keyword}${step.text}`);
    }
    async afterStep(step, scenario, result) {
        var _a;
        await ((_a = this._insightsHandler) === null || _a === void 0 ? void 0 : _a.afterStep(step, scenario, result));
    }
    async onReload(oldSessionId, newSessionId) {
        if (!this._browser) {
            return Promise.resolve();
        }
        const { setSessionName, setSessionStatus } = this._options;
        const hasReasons = this._failReasons.length > 0;
        const status = hasReasons ? 'failed' : 'passed';
        if (!this._browser.isMultiremote) {
            log.info(`Update (reloaded) job with sessionId ${oldSessionId}, ${status}`);
        }
        else {
            const browserName = this._browser.instances.filter((browserName) => this._browser && this._browser[browserName].sessionId === newSessionId)[0];
            log.info(`Update (reloaded) multiremote job for browser "${browserName}" and sessionId ${oldSessionId}, ${status}`);
        }
        if (setSessionStatus) {
            await this._update(oldSessionId, {
                status,
                ...(setSessionName ? { name: this._fullTitle } : {}),
                ...(hasReasons ? { reason: this._failReasons.join('\n') } : {})
            });
        }
        this._scenariosThatRan = [];
        delete this._suiteTitle;
        delete this._fullTitle;
        this._failReasons = [];
        await this._printSessionURL();
    }
    _isAppAutomate() {
        var _a, _b, _c;
        const browserDesiredCapabilities = ((_b = (_a = this._browser) === null || _a === void 0 ? void 0 : _a.capabilities) !== null && _b !== void 0 ? _b : {});
        const desiredCapabilities = ((_c = this._caps) !== null && _c !== void 0 ? _c : {});
        return !!browserDesiredCapabilities['appium:app'] || !!desiredCapabilities['appium:app'] || !!browserDesiredCapabilities.app || !!desiredCapabilities.app;
    }
    _updateJob(requestBody) {
        return this._multiRemoteAction((sessionId, browserName) => {
            log.info(browserName
                ? `Update multiremote job for browser "${browserName}" and sessionId ${sessionId}`
                : `Update job with sessionId ${sessionId}`);
            return this._update(sessionId, requestBody);
        });
    }
    _multiRemoteAction(action) {
        const { _browser } = this;
        if (!_browser) {
            return Promise.resolve();
        }
        if (!_browser.isMultiremote) {
            return action(_browser.sessionId);
        }
        return Promise.all(_browser.instances
            .filter(browserName => {
            const cap = (0, util_1.getBrowserCapabilities)(_browser, this._caps, browserName);
            return (0, util_1.isBrowserstackCapability)(cap);
        })
            .map((browserName) => (action(_browser[browserName].sessionId, browserName))));
    }
    _update(sessionId, requestBody) {
        if (!(0, util_1.isBrowserstackSession)(this._browser)) {
            return Promise.resolve();
        }
        const sessionUrl = `${this._sessionBaseUrl}/${sessionId}.json`;
        log.debug(`Updating Browserstack session at ${sessionUrl} with request body: `, requestBody);
        return got_1.default.put(sessionUrl, {
            json: requestBody,
            username: this._config.user,
            password: this._config.key
        });
    }
    async _printSessionURL() {
        if (!this._browser || !(0, util_1.isBrowserstackSession)(this._browser)) {
            return Promise.resolve();
        }
        await this._multiRemoteAction(async (sessionId, browserName) => {
            const sessionUrl = `${this._sessionBaseUrl}/${sessionId}.json`;
            log.debug(`Requesting Browserstack session URL at ${sessionUrl}`);
            const response = await (0, got_1.default)(sessionUrl, {
                username: this._config.user,
                password: this._config.key,
                responseType: 'json'
            });
            if (!this._browser) {
                return;
            }
            const capabilities = (0, util_1.getBrowserCapabilities)(this._browser, this._caps, browserName);
            const browserString = (0, util_1.getBrowserDescription)(capabilities);
            log.info(`${browserString} session: ${response.body.automation_session.browser_url}`);
        });
    }
    async _setSessionName(suiteTitle, test) {
        if (!this._options.setSessionName || !suiteTitle) {
            return;
        }
        let name = suiteTitle;
        if (this._options.sessionNameFormat) {
            name = this._options.sessionNameFormat(this._config, this._caps, suiteTitle, test === null || test === void 0 ? void 0 : test.title);
        }
        else if (test && !test.fullName) {
            // Mocha
            const pre = this._options.sessionNamePrependTopLevelSuiteTitle ? `${suiteTitle} - ` : '';
            const post = !this._options.sessionNameOmitTestTitle ? ` - ${test.title}` : '';
            name = `${pre}${test.parent}${post}`;
        }
        if (name !== this._fullTitle) {
            this._fullTitle = name;
            await this._updateJob({ name });
        }
    }
    _setAnnotation(data) {
        return this._executeCommand('annotate', { data, level: 'info' });
    }
    async _executeCommand(action, args) {
        if (!this._browser || !(0, util_1.isBrowserstackSession)(this._browser)) {
            return Promise.resolve();
        }
        const cmd = { action, ...(args ? { arguments: args } : {}) };
        const script = `browserstack_executor: ${JSON.stringify(cmd)}`;
        if (this._browser.isMultiremote) {
            const multiRemoteBrowser = this._browser;
            return Promise.all(Object.keys(this._caps).map(async (browserName) => {
                const browser = multiRemoteBrowser[browserName];
                return (await browser.execute(script));
            }));
        }
        return (await this._browser.execute(script));
    }
}
exports.default = BrowserstackService;
